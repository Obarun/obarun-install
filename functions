#!/usr/bin/bash
## This script is under license BEER-WARE.
# "THE BEER-WARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal

shopt -s extglob

#export TMPDIR=

##		Shell color 

unset bold reset red bred green bgreen yellow byellow blue bblue
bold=$(tput bold)
reset=$(tput sgr0)
red=$(tput setaf 1)
bred=${bold}$(tput setaf 1)
green=$(tput setaf 2)
bgreen=${bold}$(tput setaf 2)
yellow=$(tput setaf 3)
byellow=${bold}$(tput setaf 3)
blue=$(tput setaf 4)
bblue=${bold}$(tput setaf 4)
#readonly bold reset red bred green bgreen yellow byellow blue bblue

## 		Information display by the script 

echo_bold(){
	local msg=$1; shift 
	printf "${bold}${msg}${reset}\n" "${@}" >&1
}
echo_info(){
	local msg=$1; shift 
	printf "${byellow}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_info_menu(){
	local msg=$1; shift 
	printf "${byellow}${msg} ${reset}\n" "${@}" >&1
}
echo_retry(){
	local msg=$1; shift 
	printf "${bblue}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_valid(){
	local msg=$1; shift 
	printf "${bgreen}    ->${msg} ${reset}\n" "${@}" >&1
}
echo_notvalid(){
	local msg=$1; shift 
	printf "${byellow}    ->${msg} ${reset}\n" "${@}" >&1
}
echo_display(){
	local msg=$1; shift 
	printf "${bold}==>>${msg} ${reset}\n" "${@}" >&1
}
echo_error(){
	local msg=$1; shift 
	printf "${bred}    ->${msg} ${reset}\n" "${@}" >&2
}
answer(){
	echo_retry " Please answer y or n :"
}

## 		Some variables for installation

home_path=$(readlink -f ${0%/*})
newroot="/mnt"
editor="mcedit"
dir="$home_path"
config_dir="openbox"
gen_dir="$dir/config"
cache_dir="/var/cache/pacman/pkg"
yaourt_cache="$newroot/var/cache/pacman/pkg" 
tmp_yaourt="$newroot/tmp/"
gpg_dir="/opt/obarun-install/gnupg"
file_mounted=""
newuser=""
zone=""
subzone=""
hostname=""
keymap=""
xkeymap=""
locale=""
pack=0
rc=""
git_addr="https://github.com/Obarun/obarun-install.git"

##		Some variables for making iso

iso_root="$newroot"
iso_name=obarun
iso_version=v0.5.2
iso_label="OBARUN_$(date +%Y)-$iso_version"
install_dir=arch ### directory inside iso
base_dir="${home_path}"
work_dir="${base_dir}/work"
out_dir="${base_dir}/out"
make_iso="${base_dir}/make_iso"
arch=$(uname -m)
verbose="-v"
d_verbose="yes"
quiet="y"
run_cmd=""
pkg_list=""
iso_publisher="Obarun Linux <http://www.obarun.org>"
iso_application="Obarun Linux Live/Rescue CD"
sfs_mode="sfs"
sfs_comp="xz"

## 		Exit

die (){
      local message 
      message="$1"
 
      if [[ -n "$message" ]] ; then
        echo "${bred}==>> Error: ${message}${reset}"
      else
        echo "${bred}==>> Error: Script can not continue"
      fi
      exit 1
}

## 		Clean on exit

clean_install(){
	
	# make sure that all process are killed
	# before umounting 
	pkill haveged
	pkill gpg-agent
	pkill dirmngr
	
	if [[ $(mount | grep "$newroot"/proc) ]]; then
		mount_umount "$newroot" "umount"
	fi
	if [[ $(mount | grep "$work_dir/airootfs/proc") ]]; then
		mount_umount "$work_dir/airootfs" "umount"
	fi
	if [[ $(awk -F':' '{ print $1}' /etc/passwd | grep usertmp) >/dev/null ]]; then
		echo_valid " Removing user usertmp"
		rem_usertmp &>/dev/null
	fi
	if [[ -e /etc/yaourtrc.ori.obarun ]]; then
		mv /etc/yaourtrc.ori.obarun /etc/yaourtrc
	fi
	if [[  -e "$newroot/etc/functions" ]]; then
		rm "$newroot/etc/functions" || die "File functions not exist"
	fi
	if [[  -e "$newroot/etc/customizeChroot" ]]; then
		rm "$newroot/etc/customizeChroot" || die " File customizeChroot not exist"
	fi
	
	exit
}

##		check if $newroot is a valid mountpoint

check_mountpoint(){
	if ! mountpoint -q "$newroot"; then
			echo_retry " This is not a valid mountpoint"
			echo_retry " You need to mount a device on $newroot or choose another directory"
			(sleep 4) && echo_info " Returning to the main_menu" && (sleep 1) && main_menu
	fi
}


## 		Mount/unmount necessary directory
# $1 name of directory to check 
# $2 action to do : mount/umount

mount_umount(){
	local rep action
	rep="$1"
	action="$2"
	
	_mount(){
		echo_notvalid " Mounting $4"
		mount "$@" 
	}
	
	_umount(){
		echo_notvalid " Unmounting $1"
		umount $@
	}
			
	if [[ "$action" == "mount" ]]; then
		echo_display " Check mounted filesystem on $rep"
		if ! [[ $(mount | grep "$rep"/proc) ]]; then
			_mount -t proc proc "$rep/proc" -o nosuid,noexec,nodev 
			_mount -t sysfs sys "$rep/sys" -o nosuid,noexec,nodev 
			_mount -t devtmpfs dev "$rep/dev" -o mode=0755,nosuid
			_mount -t devpts devpts "$rep/dev/pts" -o mode=0620,gid=5,nosuid,noexec
			_mount -t tmpfs shm "$rep/dev/shm" -o mode=1777,nosuid,nodev
			_mount -t tmpfs run "$rep/run" -o nosuid,nodev,mode=0755
			_mount -t tmpfs tmp "$rep/tmp" -o mode=1777,strictatime,nodev,nosuid
		else
			echo_valid " Filesystem already mounted in ${rep}"
		fi
	fi
	if [[ "$action" == "umount" ]]; then
		echo_display " Check mounted filesystem"
		if [[ $(mount | grep "$rep"/proc) ]]; then
			_umount "$rep/proc"
			_umount "$rep/sys"
			_umount "$rep/dev/pts"
			_umount "$rep/dev/shm"
			_umount "$rep/run"
			_umount "$rep/tmp"
			_umount "$rep/dev"
		else
			echo_valid " Filesystem not mounted in ${rep}"
		fi
	fi
	unset rep action
}

## 		Remove usertmp

rem_usertmp(){
	echo_display " Removing user : usertmp"
	userdel -r usertmp
	sed -i '/usertmp/d' /etc/sudoers
}

##		Update package automaticaly

pac_update(){
	echo_display " Check obarun-install version"
	local status pkgname build_dir rc 
	pkgname="obarun-install"
	rc=0
	
	# make build_dir directory
	make_build_dir(){
		if ! [ -d "$dir/.build" ]; then
			echo_notvalid " Create necessary directory"
			mkdir -p -m0755 "$dir/.build"
			build_dir="$dir/.build"
		else
			build_dir="$dir/.build"
		fi
	}
	
	# check if pkgbuild exist
	copy_pkgbuild(){
		echo_notvalid " Copy PKGBUILD to ${green}[$build_dir/$pkgname]${reset}"
		cp -f "$build_dir/$pkgname"/.PKGBUILD "$build_dir/$pkgname/PKGBUILD"
	}
	
	# make package
	make_package(){
		user_tmp
		copy_pkgbuild || die " Impossible to copy .PKGBUILD"
		chown -R usertmp:users "$build_dir/$pkgname"
		cd "$build_dir/$pkgname"
		echo_notvalid " Launch makepkg and install the new version if exist"
		sudo -u usertmp makepkg -Cfi --nosign --noconfirm --needed
		sleep 2
	}
	
	# check git repositories
	check_update(){
		cd "$build_dir/$pkgname"
		status=$(git pull origin 2>/dev/null)
		if [[ $status == "Already up-to-date." ]]; then
			echo_valid " Git $status Nothing to do"
			sleep 2
		else
			rc=1
		fi
	}
	
	# check current version 
	check_version(){
		cd "$build_dir/$pkgname"
		local curr_version git_version
		curr_version=$(pacman -Qi obarun-install | grep "Version" | awk -F": " '{print $2}' | sed 's:-1::')
		git_version=$(git rev-parse --short HEAD)
		
		check_update || die " Impossible to udpdate $pkgname"
		
		if [[ $rc == 1 ]]; then
			unset rc
			echo_display " $pkgname is out of date, updating please wait"
			make_package || die " Impossible to make the package"
			rc=1
		fi
		if ! [[ "$curr_version" == "$git_version" ]]; then
			if [[ $rc == 1 ]]; then
				unset rc
				break
			else
				make_package || die " Impossible to make the package"
			fi
		fi
	}	
		
	make_build_dir
	
	if ! [ -d "$build_dir/$pkgname" ]; then
		cd "$build_dir"
		echo_notvalid " Clone repository form ${green}[$git_addr]${reset}"
		git clone "$git_addr"
		make_package || die " Impossible to make the package"
	else
		check_version || die " Impossible to check the current version"
	fi	
	
	cd "$dir"
}

## 		Create needed directory

create_dir(){
	echo_display " Check for needed directory"
	if ! [ -d "$newroot/proc" ]; then 
		echo_notvalid " Create needed directory in ${newroot}"
		mkdir -m 0755 -p "$newroot"/var/{cache/pacman/pkg,lib/pacman,log} "$newroot"/{dev,run,etc}
		mkdir -m 0755 -p "$newroot"/dev/{pts,shm}
		mkdir -m 1777 -p "$newroot"/tmp
		mkdir -m 0555 -p "$newroot"/{sys,proc}
	else
		echo_valid " Directory needed already exists"
	fi
}

## 		Check list option

check_elements(){
	for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

## 		Select, check editor

select_editor(){
	local old_editor
	old_editor="$editor"
	editors_list=("nano" "vi" "mcedit" "Exit");
	echo_display " Select your editor :"
	select editor in "${editors_list[@]}"; do
		case "$editor" in
			Exit)editor="$old_editor"
				break;;
			*)if check_elements "$editor" "${editors_list[@]}"; then
					echo_valid " Your editor is now : $editor"
					break
			  else 
					echo_retry " Invalid number, retry :"
			  fi
		esac
	done
}

check_editor(){
	if [[ "$editor" == "" ]]; then
		editor="mcedit"
	fi
}

## 		Select config directory

choose_dir(){
	dir_list=$(ls -U `pwd`/config/)
	echo_display " Select the directory you want to use :"
	select directory in $dir_list; do
		if check_elements "$directory" $dir_list; then
			config_dir="$directory"	 
		break
		else 
			echo_retry " Invalid number, retry :"
		fi
	done
	echo_valid " You chose $config_dir"
}

##		Choose cache directory for pacman

choose_cache(){
	echo_display " Enter the path for your own cache directory"
	read -e cache_dir
	while [[ ! -d "$cache_dir" ]]; do
		echo_retry " $cache_dir is not a directory, please retry:"
		read -e cache_dir
	done
	# the directory must be not empty, may be bug here
	#while [[ $(ls $cache_dir | grep "pkg.tar.xz") = "" ]]; do
	#	echo_retry " Is not a valid directory for pacman, please retry:"
	#	read -e cache_dir
	#done
	echo_valid " Your cache directory is now : $cache_dir"
}

## 		Edit pacman.conf

edit_pacman(){
	check_editor
	"$editor" "$gen_dir/$config_dir/pacman.conf"		
}

## 		Edit customizeChroot file

edit_customize_chroot(){
	check_editor
	"$editor" "$gen_dir/$config_dir/customizeChroot"
	if [[ -d "$newroot/etc" ]]; then
		echo_display " Copying customizeChroot to $newroot/etc/customizeChroot"
		cp -f "$gen_dir/$config_dir/customizeChroot" "$newroot/etc/customizeChroot" || die " File customizeChroot not exist, you need to choose number 7 first"
	fi
}

## 		Create temporary users for yaourt

user_tmp(){
	if ! [[ $(awk -F':' '{ print $1}' /etc/passwd | grep usertmp) ]]; then
		echo_display " Create a temporary user needed for the scripts"
			if [[ -e /etc/sudoers ]]; then
				# declaring usetmp on adm group is certainly a bad idea
				useradd -m -g users -G "wheel,disk,storage,optical,floppy,adm,network" -s /bin/bash usertmp || die " Impossible to create user : usertmp"
				echo "%usertmp ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
			else
				echo "${bred}==>> The file /etc/sudoers doesn't exists,"
				echo_notvalid " Installing sudo package"
				pacman -S sudo
				user_tmp
			fi
	fi
}

		
## 		Select root directory
## $1 name of variable to define
## $2 check if the functions is for define newroot or iso_root
## need improvement for this functions

rootdir(){	
	local directory var
	directory="$1"
		
	echo_display " Enter your root directory :"
	read -e var
	local rc
	rc=${2:-0}
	
	until [[ -d "$var" ]]; do
		echo_retry " This is not a directory, please retry :"
		read -e var
	done
	if (( ! rc )); then
		while ! mountpoint -q "$var"; do
			echo_retry " This is not a valide mountpoint, please retry :"
			read -e var
		done
		unset rc
	fi
	case $directory in
		newroot)
			newroot=$var;;
		iso_root)
			iso_root=$var;;
	esac
	
	if (( ! rc )); then
		echo_valid " Your root directory for installation is now : $newroot"
	else
		echo_valid " The directory to copy is : $iso_root"
	fi
}

## Check if needed packages is installed

check_pac_needed(){
	echo_display " Check packages needed for the script"
	if [[ ! $(pacman -Qs arch-install-scripts) >/dev/null ]]; then
		echo_notvalid " Installing arch-install-scripts"
		pacman -S arch-install-scripts --config "$gen_dir/$config_dir/pacman.conf" || die " Impossible to install the package arch-install-scripts"
	else
		echo_valid " arch-install-scripts : already installed"
	fi
	if [[ ! $(pacman -Qs yaourt) >/dev/null ]]; then
		echo_notvalid " Installing yaourt"
		pacman -S base-devel package-query yaourt --config "$gen_dir/$config_dir/pacman.conf" || die " Impossible to install the package arch-install-scripts"
	else
		echo_valid " yaourt : already installed"
	fi
}

##		Select packages list

select_list(){
	local list
	check_editor
	pac_list=$(ls "$gen_dir"/"$config_dir"/package_list/)
	pac_list+=" Exit"
	echo_display " File named repo_* concerns the packages provides by repositories defined in pacman.conf"
	echo_display " File named aur_* concerns the packages from AUR"
	echo_display " Select the list you want to edit then select Exit number to return at main menu :"
	select list in $pac_list; do
		case "$list" in
			Exit)break;;
			*)if check_elements "$list" $pac_list; then
				"$editor" "$gen_dir/$config_dir/package_list/$list"
			  else 
				echo_retry " Invalid number, retry :"
			  fi
		esac
	done
}

##		Copying file needed

copy_file(){
	echo_display " Check needed files in ${newroot}"
	if [[  ! -e "$newroot/etc/resolv.conf" ]]; then 
		cp /etc/resolv.conf "$newroot/etc/resolv.conf" || die " Impossible to copy the file resolv.conf"
	else
		echo_valid " File resolv.conf already exist"
	fi
	if [[ ! -e "$newroot/etc/functions" ]]; then
		cp "`pwd`/functions" "$newroot/etc/functions" || die "File functions not exist"
	else
		echo_valid " File functions already exist"
	fi
	if [[ ! -e "$newroot/etc/customizeChroot" ]]; then
		cp "$gen_dir/$config_dir/customizeChroot" "$newroot/etc/customizeChroot" || die " File customizeChroot not exist"
	else
		echo_valid " File customizeChroot already exist"
	fi
}

##		Install packages if pack = 0 otherwise call resume_install function

install_pack(){
	
	if [[ "$pack" == 0 ]]; then
		echo_display " Install packages from lists"
		pac_install || die " Impossible to install packages from repository" 
		aur_install || die " Impossible to install packages from AUR"
	else
		resume_install
		aur_install
	fi
			
}

##		Only install packages are not present yet

resume_install(){
	local item item_base
	local -a installed not_installed base_installed list list_base result result_base
	
	# TODO : bug -> n°7 need to be launch one time else /var/lib/pacman doesn't exist
	mapfile -t installed < <(pacman -r "$newroot" -Qsq)
	mapfile -t not_installed < <(grep -h -v ^# $gen_dir/$config_dir/package_list/repo_*)
	mapfile -t base_installed < <(grep -h -v ^# $gen_dir/$config_dir/package_list/base)
	
	# check first for base packages
	echo_display " Check base installed packages for pacman"
	list_base=" ${installed[@]} "
		for item_base in ${base_installed[@]}; do
			if ! [[ $list_base =~ " $item_base " ]] ; then
				result_base+=($item_base)
			fi
		done
	#install base package	
	if [[ -n "${result_base[@]}" ]]; then
		echo_notvalid " Install missing base packages"
		pacman -r "$newroot" -S "${result_base[@]}" --config "$gen_dir/$config_dir/pacman.conf" --cachedir "$cache_dir" --noconfirm 2>/dev/null || die " Failed to install packages"
		result_base=()
	else
		echo_valid " Nothing to do for base system"
	fi	
		
	echo_display " Ckeck installed packages for pacman"
	list=" ${installed[@]} "                #include blank    
		for item in ${not_installed[@]}; do
			if ! [[ $list =~ " $item " ]] ; then  
				result+=($item)
			fi
		done
	
	#install package
	if [[ -n "${result[@]}" ]]; then
		echo_notvalid " Install missing packages"
		pacman -r "$newroot" -S "${result[@]}" --config "$gen_dir/$config_dir/pacman.conf" --cachedir "$cache_dir" --noconfirm 2>/dev/null || die " Failed to install packages"
		result=()
	else
		echo_valid " Nothing to do for pacman"
	fi
}

## 		Install packages with pacman

pac_install(){
		echo_display " Install base first"
		pacman -r "$newroot" -S $(grep -h -v ^# $gen_dir/$config_dir/package_list/base) --config "$gen_dir/$config_dir/pacman.conf" --cachedir "$cache_dir" --noconfirm #2>/dev/null || die " Failed to install packages"
		pacman -r "$newroot" -S $(grep -h -v ^# $gen_dir/$config_dir/package_list/repo_*) --config "$gen_dir/$config_dir/pacman.conf" --cachedir "$cache_dir" --noconfirm #2>/dev/null || die " Failed to install packages"
}

## 		Install package from aur

aur_install(){
	chmod -R 0777 "$yaourt_cache" ## this turn around is little ugly but necessary to allow written by user "usertmp"
	if [[ ! -d "$newroot/var/lib/pacman/sync" ]]; then 
		sync="y"
	else
		sync=""
	fi
		
	if [[ ! -e /etc/yaourtrc.ori.obarun ]]; then
		if [[ -e /etc/yaourtrc ]]; then
			cp /etc/yaourtrc /etc/yaourtrc.ori.obarun
		fi
		sed -i "s:#TMPDIR=.*$:TMPDIR=$tmp_yaourt:" /etc/yaourtrc
		sed -i "s:#EXPORT=.*$:EXPORT=1:" /etc/yaourtrc
		sed -i "s:#EXPORTDIR=.*$:EXPORTDIR=$yaourt_cache:" /etc/yaourtrc
	fi	
	aur_cache
	chmod -R 0755 "$yaourt_cache"
}

aur_cache(){
	local list item hit wanted name p_hit passed
	local -a installed notinstalled y_cached p_cached result
	
	mapfile -t installed < <(pacman -r "$newroot" -Qsq)
	mapfile -t notinstalled < <(cat $gen_dir/$config_dir/package_list/aur_* | grep -v "#" | sed  '/^ *$/d')
	mapfile -t y_cached < <(ls -1 -p $yaourt_cache/ | grep -v '/$' | grep -v "gz" | sed 's/-[0-9].*$//g')
	mapfile -t p_cached < <(ls $cache_dir | sed 's/-[0-9].*$//g' | uniq)
	
	echo_display " Ckeck installed packages for yaourt"
	# diff between wanted and installed	
	list=" ${installed[@]} "                  
	for item in "${notinstalled[@]}"; do
		if ! [[ $list =~ " $item " ]] ; then  
			result+=($item,)
		fi
	done
	
	# TODO : FAIL try to install a package group instead of package name
	# install from cache if present else download it
	if [[ -n "${result[@]}" ]]; then
		while read -d "," wanted; do
			if [[ -n "${y_cached[@]}" ]]; then
				for name in "${y_cached[@]}"; do
					if [ $name = $wanted ]; then
						hit=0
					fi
				done
				for name in "${p_cached[@]}";do
					if [ $name = $wanted ]; then
						p_hit=0
					fi
				done
				if [[ $p_hit = 0 ]]; then
						# check for last version
						# TODO : can cause problem if the cache directory is out of date, need to be improved
						pack=$(ls -1t $cache_dir | grep $wanted | head -1) 
						pacman -r "$newroot" -U"$sync" "$cache_dir"/$pack --noconfirm || die " Failed to install packages" 
						p_hit=""
						hit=""
						passed=0
				fi
				if [[ $hit = 0 ]]; then
					pacman -r "$newroot" -U"$sync" "$yaourt_cache"/$wanted*.xz --noconfirm || die " Failed to install packages" 
					hit=""
				else
					if [[ $passed != 0 ]]; then
						sudo -u usertmp yaourt -r "$newroot" -S"$sync" "$wanted" --noconfirm || die " Failed to install packages" 
						hit=""
						passed=""
					fi
				fi
			else
				sudo -u usertmp yaourt -r "$newroot" -S"$sync" "$wanted" --noconfirm || die " Failed to install packages"
			fi
		done <<< ${result[@]}
	else
		echo_valid " Nothing to do for yaourt"
	fi
}

##		Sync database

sync_data(){
	
	echo_display " Synchronize database"
	pacman -Sy --config "$gen_dir/$config_dir/pacman.conf" || die " Impossible to synchronize database"
	
	echo_display " Copying database on $newroot/var/lib/pacman/sync/"	
	mkdir -p -m0755 "$newroot/var/lib/pacman/sync/"
	cp /var/lib/pacman/sync/*.db "$newroot/var/lib/pacman/sync/" || die "/var/lib/pacman/sync/*.db doesn't exit on host"
		
}

##		Generate key

pac_key(){
	
	local gpg_opts
	
	if ! [ -z "$1" ]; then
		gpg_opts="--gpgdir $1"
	fi
	
	echo_display " Start pacman-key"
	haveged -w 1024
	
	pacman-key --init $gpg_opts
	pacman-key --populate archlinux $gpg_opts
	
	# unset gpg_opts
	gpg_opts=
}

check_gpg(){
	
	local gpg_opts
	
	if ! [ -z "$1" ]; then
		gpg_opts="--gpgdir $1"
	fi
	# pacman-key -r failed without /root/.gnupg
	# create it by dirmngr
	# TODO: find a turn around
	if ! [ -d /root/.gnupg ]; then
		dirmngr &>/dev/null & pkill dirmngr
	fi
	
	echo_display " Check if gpg key exist"	
	if ! pacman-key -u $gpg_opts &>/dev/null; then
		echo_notvalid " Gpg doesn't exist, create it..."
		if ! [ -z $gpg_opts ]; then
			pac_key "$gpg_dir"
		else
			pac_key
		fi
	else
		echo_valid " Gpg key exist, Refresh it..."
		pacman-key -u $gpg_opts
	fi
	
	# TODO : make a function to let the choice at user to add or not Eric vidal key
	# or adding a personal key
	echo_display " Check if Eric Vidal gpg signature exist"
	if ! pacman-key --list-keys 7B45DAAC $gpg_opts &>/dev/null; then
		echo_notvalid " Add Eric Vidal gpg signature, please wait"
		pacman-key -r 7B45DAAC $gpg_opts
		pacman-key --lsign-key 7B45DAAC $gpg_opts
	else
		echo_valid " Eric Vidal gpg signature already exist"
	fi
	
	# unset gpg_opts
	unset gpg_opts
	kill_(){
		local k
		for k in haveged gpg-agent dirmngr; do
			killall -r $k 2>/dev/null
		done
		unset k
	}
	kill_
}

##		Generate fstab

gen_fstab(){
	echo_display " Generate fstab"
	genfstab -p "$newroot" > "$newroot/etc/fstab" || die " Impossible to generate fstab"
}

##		Copy directory rootfs in $newroot

copy_rootfs(){
	echo_display " Copying configuration files in ${newroot}"
	cp -af `pwd`/config/"$config_dir"/rootfs/* "$newroot"/ || die " Impossible to copy files"
}

##		Customize newroot

enter_chroot(){
	# make sure the necessary is present before enter on chroot
	check_mountpoint
	create_dir
	mount_umount "$newroot" "mount"
	user_tmp
	copy_file
	copy_rootfs
	define_root
	
	echo_display " Enter on chroot of ${newroot}"	
	chroot "$newroot" /etc/customizeChroot || die " Failed to enter on ${newroot} or Failed to execute functions customizeChroot"
}

##		Enter in $newroot with mc

mc_newroot(){
	check_mountpoint
	create_dir
	mount_umount "$newroot" "mount"
	SHELL=/bin/sh chroot "$newroot" /usr/bin/mc
}

##		Open an interactive shell on newroot

call_shell(){
	check_mountpoint
	create_dir
	mount_umount "$newroot" "mount"
	echo_info " Tape exit when you have finished"
	if [[ -e "$newroot/usr/bin/zsh" ]]; then
		SHELL=/bin/sh chroot "$newroot" /usr/bin/zsh 
	else
		SHELL=/bin/sh chroot "$newroot"
	fi
}

##		Define root user

define_root(){
	if [[ ! $(cat $newroot/etc/shadow | grep "root::") == "" ]]; then
		echo_display " Change shell for root user on $newroot"
		usermod -R "$newroot" -s /usr/bin/zsh root
		
		echo_display " Copy skeleton to $newroot/root/"
		cp -rT "$newroot/etc/skel/" "$newroot/root/"
		
		chmod 0750 "$newroot/root"
		
		echo_display " You need to define root password"
		pass_root
		echo_valid " root user was modified successfully"
	fi
	if [[ -e "$newroot/root/.zlogin" ]]; then
		echo_display " Removing auto-login for root"
		rm "$newroot/root/.zlogin"
	fi
}

pass_root(){
	passwd -R "$newroot" root
	while [[ $? -ne 0 ]]; do
		echo_retry " Password do not match, please retry"
		passwd -R "$newroot" root
	done
}


##		Start the installation

install_system(){
	check_mountpoint
	create_dir
	mount_umount "$newroot" "mount"
	user_tmp
	copy_file
	check_gpg "$gpg_dir"
	sync_data
	check_pac_needed
	install_pack
	gen_fstab
	copy_rootfs
	define_root
	pack=0
}

## 		Main menu

main_menu(){

local step=100

while [[ "$step" !=  14 ]]; do
	clear
	echo_bold ""
	echo_bold ""
	echo_info_menu "***************************************************************************************"
	echo_info_menu "                            Main menu"
	echo_info_menu "***************************************************************************************"
	echo_bold ""
	echo_bold " Assumptions :"
	echo_bold "	- User has partitioned, formatted, and mounted partitions on a directory"
	echo_bold "	- Network is functional"
	echo_bold "	- A valid mirror appears in /etc/pacman.d/mirrorlist"
	echo_bold "	- Defaults for the options are specified in brackets"
	echo_bold ""
	echo_info_menu "***************************************************************************************"
	echo_info_menu "                            Configuration"
	echo_info_menu "***************************************************************************************"
	echo_bold ""
	echo_bold " 1  -  Select Editor ${green}[$editor]"
	echo_bold " 2  -  Choose your Desktop environment ${green}[$config_dir]"
	echo_bold " 3  -  Edit pacman.conf file used by the script"
	echo_bold " 4  -  Define cache directory for pacman ${green}[$cache_dir]"
	echo_bold " 5  -  Edit the list of packages that will be installed (AUR including)"
	echo_bold " 6  -  Enter root directory for installation ${green}[$newroot]"
	echo_bold ""
	echo_info_menu "***************************************************************************************"
	echo_info_menu "                            Installation"
	echo_info_menu "***************************************************************************************"
	echo_bold ""
	echo_bold " 7  -  Install the base system"
	echo_bold " 8  -  Launch the script customizeChroot"
	echo_bold ""
	echo_bold " 9  -  Resume an aborted installation"	 	
	echo_bold ""
	echo_info_menu "***************************************************************************************"
	echo_info_menu "                            Expert mode"
	echo_info_menu "  Assumptions : the base system must be installed at least before using this mode"
	echo_info_menu "***************************************************************************************"
	echo_bold ""
	echo_bold " 10 -  Edit the script customizeChroot"
	echo_bold " 11 -  Launch a shell on ${green}[$newroot]${reset}${bold} directory"
	echo_bold " 12 -  Browse ${green}[$newroot]${reset}${bold} with Midnight Commander"
	echo_bold " 13 -  Make an iso"
	echo_bold ""
	echo_bold ""
	echo_bold " ${red}14 -  Exit installation script"
	echo_bold ""
	echo_bold ""
	echo_display " Enter your choice :";read  step

		case "$step" in 
			1)	select_editor;;
			2)	choose_dir;; # Never comment this options
			3)	edit_pacman;;
			4)	choose_cache;;
			5)	select_list;;
			6)	rootdir "newroot";; # Never comment this options
			7)	install_system;;
			8)	enter_chroot;;
			9)	pack=1
				install_system;;
			10)	edit_customize_chroot;;
			11) call_shell;;
			12)	mc_newroot;;
			13) enter_iso;;
			14) echo_display " Exiting"
				exit;;
			*) echo_retry " Invalid number, Please retry: "
		esac
		echo_info " Press enter to return to the Main menu"
		read enter 
done
}

#####################################		Functions for customizeChroot script

## 		CustomizeChroot menu

customizeChroot_menu(){

local step=100

while [[ "$step" !=  11 ]]; do
	clear
	echo_bold ""
	echo_bold ""
	echo_info_menu "**************************************************************"
	echo_info_menu "              CustomizeChroot menu"
	echo_info_menu "**************************************************************"
	echo_bold ""
	echo_bold " 1  -  Define hostname ${green}[$hostname]"
	echo_bold " 2  -  Define locale ${green}[$locale]"
	echo_bold " 3  -  Define localtime ${green}[$zone/$subzone]"
	echo_bold " 4  -  Define console keymap ${green}[$keymap]"
	echo_bold " 5  -  Define desktop keymap ${green}[$xkeymap]"
	echo_bold " 6  -  Create a new user ${green}[$newuser]"
	echo_bold ""
	echo_bold " 7  -  Continue the installation"
	echo_bold ""
	echo_info_menu "**************************************************************"
	echo_info_menu "                   Expert mode"
	echo_info_menu "**************************************************************"
	echo_bold ""
	echo_bold " 8  -  Edit rc.conf file"
	echo_bold " 9  -  Browse with Midnight Commander"
	echo_bold " 10 -  Delete custo_once files"
	echo_bold ""
	echo_bold ""
	echo_bold " ${red}11  -  Return to the main menu"
	echo_bold ""
	echo_bold ""
	echo_display " Enter your choice :";read  step

		case "$step" in 
			1)	define_hostname;;
			2)	define_locale;; 
			3)	call_localtime;;
			4)	define_keymap;;
			5)	define_xkeymap;;
			6)	define_user;;
			7)	echo_display " Continue installation"
				break;;
			8)	edit_rc_conf;;
			9)	mc_enter;;
			10)	clean_once_file rm "/root/tmp/obarun-install";;
			11)	exit;;
			*) echo_retry " Invalid number, please retry:"
		esac
		echo_info " Press enter to return to the customizeChroot menu"
		read enter 
done
}

##		Define resolv.conf

define_resolv(){
	echo_display " Define resolv.conf"
	if [[ -e /etc/resolv.conf.pacorig ]]; then 
		mv /etc/resolv.conf.pacorig /etc/resolv.conf
	fi
}


##		Enter in the fresh installation with mc

mc_enter(){
	mc /
}

## 		Define hostname

define_hostname(){
	if [[ "$hostname" != "" ]]; then
		sed -i 's/ .*$//' /etc/hosts
	fi
	echo_display " Enter your hostname"
	read hostname
	sed -i "s/HOSTNAME=\".*$/HOSTNAME=\"$hostname\"/g" /etc/rc.conf
	echo "$hostname" > /etc/hostname
	sed -i '/127.0.0.1/s/$/ '$hostname'/' /etc/hosts
	sed -i '/::1/s/$/ '$hostname'/' /etc/hosts
	echo_valid " hostname is now : $hostname"
}

##		Edit rc.conf

edit_rc_conf(){
	"$editor" /etc/rc.conf
}

##		Define locale

define_locale(){
	local enter
	echo_display " Define your locale by uncomment desired line, only one line is allowed"
	echo_info " Press enter to continue"
	read enter
	
	"$editor" /etc/locale.gen
	locale-gen
	locale=$(grep -v "#" /etc/locale.gen | awk -F " " '{ print $1 }')
	echo LANG="$locale" > /etc/locale.conf
    echo LC_COLLATE=C >> /etc/locale.conf
	
	echo_valid " Locale was created successfully"
}

##		Define localtime

define_localtime(){
	zone_list=$(ls -d --group-directories-first /usr/share/zoneinfo/* | awk -F "/usr/share/zoneinfo/" '{ print $2 }' | uniq)
	zone_list+=" Exit"
	select zone in $zone_list; do
		case $zone in 
			Exit)customizeChroot_menu
			break;;
			*)if check_elements "$zone" $zone_list; then
				if [[  -d "/usr/share/zoneinfo/$zone" ]]; then
					sub_zone_list=$(ls /usr/share/zoneinfo/$zone/* | awk -F "/usr/share/zoneinfo/$zone/" '{ print $2 }') 
					sub_zone_list+=" Exit"
					select subzone in $sub_zone_list; do
						case $subzone in
							Exit)define_localtime
								break;;
							*)if check_elements "$subzone" $sub_zone_list; then
								break
							else
								echo_retry " Invalid number, retry :"
							fi
						esac
					done
				fi
			break	
			else 
				echo_retry " Invalid number, retry :"
			fi
		esac
	done
}

call_localtime(){
	echo_display " Choose your country/department"
	define_localtime
	if [[ "$subzone" != "" ]]; then
		ln -sf /usr/share/zoneinfo/$zone/$subzone /etc/localtime
		sed -i "s/TIMEZONE=\".*$/TIMEZONE=\"$zone\/$subzone\"/g" /etc/rc.conf
	else
		ln -sf /usr/share/zoneinfo/$zone /etc/localtime
		sed -i "s/TIMEZONE=\".*$/TIMEZONE=\"$zone\"/g" /etc/rc.conf
	fi
	echo_valid " Your localtime is now : $zone/$subzone"
}

##		Define keymap

define_keymap(){
	echo_display " Choose your console keymap"
	local -a key_list
	key_list=$(ls -R /usr/share/kbd/keymaps | grep "map.gz" | sed 's/\.map\.gz//g' | sort | less)
	key_list+=" Exit"
	select keymap in $key_list; do
		case "$keymap" in
			Exit)unset keymap
				break;;
			*)if check_elements "$keymap" $key_list; then
				echo_valid " Your keymap is now : $keymap"
				break
			  else 
				echo_retry " Invalid number, retry :"
			  fi
		esac
	done
	unset key_list
	echo_valid " Set KEYMAP in rc.conf"
	sed -i "s,KEYMAP=\".*$,KEYMAP=\"$keymap\",g" /etc/rc.conf
}

##		Define xkeymap

define_xkeymap(){
	echo_display " Choose your Desktop environment keymap"
	local -a key_list
	key_list="af al am at az ba bd be bg br bt bw by ca cd ch cm cn cz de dk ee es et eu fi fo fr gb ge gh gn gr hr hu ie il in iq ir is it jp ke kg kh kr kz la lk lt lv ma md me mk ml mm mn mt mv ng nl no np pc ph pk pl pt ro rs ru se si sk sn sy tg th tj tm tr tw tz ua us uz vn za"
	key_list+=" Exit"
	select xkeymap in $key_list; do
		case "$xkeymap" in
			Exit)unset xkeymap
				break;;
			*)if check_elements "$xkeymap" $key_list; then
				echo_valid " Your Desktop keymap is now : $xkeymap"
				break
			  else 
				echo_retry " Invalid number, retry :"
			  fi
		esac
	done
	unset key_list
	# define local for root
	echo_display " Check if /root/.xinitrc exist"
	if [[ -e "/root/.xinitrc" ]]; then
		echo_valid " Define locale in /root/.xinitrc"
		sed -i 's/#setxkbmap.*$/setxkbmap\ '$xkeymap'\ \&/g' /root/.xinitrc
		sed -i 's/setxkbmap.*$/setxkbmap\ '$xkeymap'\ \&/g' /root/.xinitrc
	fi
}

##		Define a new user

define_user(){
	echo_display " Enter the name for the user"
	read newuser
	while [[ ! $(cat /etc/passwd | grep "$newuser") == "" ]]; do
		echo_retry " $newuser already exit, please enter another name :"
		read newuser
	done
	while [[ ${#newuser} -eq 0 ]] || [[ $newuser =~ \ |\' ]] || [[ $newuser =~ [^a-z0-9\ ] ]]; do
		echo_retry " Invalid user name. Please retry :"
		read newuser
	done
	echo_valid " Create user $newuser"
	useradd -m -g users -G "audio,floppy,log,network,rfkill,scanner,storage,optical,power,wheel,video" -s /usr/bin/zsh "$newuser"
	if [[ -e "/home/$newuser/.xinitrc" ]]; then
		sed -i 's/#setxkbmap.*$/setxkbmap\ '$xkeymap'\ \&/g' /home/$newuser/.xinitrc
		sed -i 's/setxkbmap.*$/setxkbmap\ '$xkeymap'\ \&/g' /home/$newuser/.xinitrc
	fi
	echo_display " You need to define $newuser password"
	pass_user
	echo_valid " User $newuser was created successfully" 
}

pass_user(){
	passwd "$newuser"
	while [[ $? -ne 0 ]]; do
		echo_retry " Password do not match, please retry"
		passwd "$newuser"
	done
}

clean_once_file(){
	local action dir f_
	action="${1}"
	dir="${2}"
	if [[ -d /root/tmp/obarun-install ]]; then
		file_list=$(ls $dir/ | uniq) 
		file_list+=" Remove_all_files"
		file_list+=" Exit"
		select file in $file_list; do
			case $file in 
				Exit)break;;
				Remove_all_files) 	for f_ in $file_list; do
										if [[ ! "$f_" = @(Exit|Remove_all_files) ]]; then
											"$action" "$dir/$f_"
										fi
									done;;
				*)if check_elements "$file" $file_list; then
						"$action" "${dir}/${file}"
						clean_once_file "$action" "$dir"				
				else 
					echo_retry " Invalid number, retry :"
					clean_once_file "$action" "$dir"
				fi
			esac
			break
		done
	else
		echo_info " Directory /root/tmp/obarun-install does not exist"
	fi
}

##		Reply functions
## return rc=0 for yes
## return rc=1 for no
reply_answer(){
	local reply
	read reply
	while [[ ! "$reply" = @(y|n) ]]; do
		answer
		read reply
	done
	if [ "$reply" == "y" ]; then
		rc=0
	else
		rc=1
	fi	
}
	
##		Define/configure Bootloader

# TODO : let the choice at user to choose between bootloader
#define_bootloader(){
	
#}

syslinux_install(){
	local opts="$1"
	echo_display " Installing bootloader: syslinux"
	syslinux-install_update $opts
	
	echo_display " Maybe the partition name in the root parameter needs to be replaced."
	echo_display " Be sure to point the root partition in the line APPEND."
	syslinux_edit
	echo_valid " Syslinux install terminate"
}

syslinux_edit(){
	echo_display " Do you want edit syslinux.cfg [y|n]"
	reply_answer
	if (( ! "$rc" )); then
		unset rc
		check_editor
		"$editor" "/boot/syslinux/syslinux.cfg"
	fi
}

syslinux_menu(){

	local step=100 options=""

	while [[ "$step" != 5 ]]; do
		clear
	
		echo_bold ""
		echo_bold ""
		echo_info_menu "**************************************************************"
		echo_info_menu "              Syslinux configuration menu"
		echo_info_menu "**************************************************************"
		echo_bold ""
		echo_bold " 1 - Install files, set boot flag, install MBR ${green}[-iam]"
		echo_bold " 2 - Install files, set boot flag ${green}[-ia]"
		echo_bold " 3 - Install only MBR ${green}[-m]"
		echo_bold " 4 - Only set boot flag ${green}[-a]"
		echo_bold ""
		echo_bold " ${red}5 - Exit"
		echo_bold ""
		echo_bold ""
		echo_display " Enter your choice :";read step

			case "$step" in
				1)	options="-iam"
					break;;
				2) 	options="ia"
					break;;
				3) 	options="-m"
					break;;
				4) 	options="-a"
					break;;
				5) 	echo_info " Exiting"
					exit;;
				*) 	echo_retry " Invalid number, please retry:"
					echo_display " Press enter to return to syslinux configuration menu"
					read enter;;
			esac	
	done
	
	syslinux_install "$options"
}


#####################################		Functions for making an iso

iso_menu(){
	
	local step=100

while [[ "$step" !=  15 ]]; do
	clear
	echo_bold ""
	echo_bold ""
	echo_info_menu "**************************************************************"
	echo_info_menu "                       Iso menu"
	echo_info_menu "**************************************************************"
	echo_bold ""
	echo_bold " 1  -  Choose directory to copy on iso ${green}[$iso_root]"
	echo_bold " 2  -  Set iso name ${green}[$iso_name]"
	echo_bold " 3  -  Set iso version ${green}[$iso_version]"
	echo_bold " 4  -  Set iso label ${green}[$iso_label]"
	echo_bold " 5  -  Set iso publisher ${green}[$iso_publisher]"
	echo_bold " 6  -  Set application name for the iso ${green}[$iso_application]"
	echo_bold " 7  -  Set installation directory inside iso ${green}[$install_dir]"
	echo_bold " 8  -  Set directory where the iso is saved ${green}[$out_dir]"
	echo_bold " 9  -  Set SquashFS image mode (img or sfs) ${green}[$sfs_mode]"
	echo_bold " 10 -  Set SquashFS compression type (gzip, lzma, lzo, xz) ${green}[$sfs_comp]"
	echo_bold ""
	echo_bold " 11 -  Start building"
	echo_bold ""
	echo_info_menu "**************************************************************"
	echo_info_menu "                      Expert mode"
	echo_info_menu "**************************************************************"
	echo_bold ""
	echo_bold " 12 -  Enable verbose ${green}[$d_verbose]"
	echo_bold " 13 -  Remove the working directory ${green}[$work_dir]"
	echo_bold " 14 -  Take a coffee"
	echo_bold ""
	echo_bold ""
	echo_bold " ${red}15  -  Return to the main menu"
	echo_bold ""
	echo_bold ""
	echo_display " Enter your choice :";read  step

		case "$step" in 
			1)	rootdir "iso_root" 1;;
			2)	define_iso_variable "iso name" "iso_name";; 
			3)	define_iso_variable "iso version" "iso_version";; 
			4)	define_iso_variable "iso label" "iso_label";; 
			5)	define_iso_variable "iso publisher" "iso_publisher";; 
			6)	define_iso_variable "application name" "iso_application";;
			7)	define_iso_variable "installation directory" "install_dir";; 
			8)	define_iso_variable "output directory" "out_dir";; 
			9)	define_iso_variable "image mode [img|sfs]" "sfs_mode";; 
			10)	define_iso_variable "compression type [gzip|lzma|lzo|xz]" "sfs_comp";; 
			11)	echo_display " Start building iso"
				break;;
			12) define_iso_variable "option for verbosity [y|n]" "verbose";;	
			13) clean_work_dir;;
			14) echo_info " Under development, not available";;
			15)	exit;;
			*) echo_retry " Invalid number, please retry:"
		esac
		echo_info " Press enter to return to the iso menu"
		read enter 
done
}

define_iso_variable(){
	local msg variable set
	msg="$1"
	variable="$2"
	
	echo_display " Enter the $msg"
	read -e set
	
	while [[ -z $set ]]; do
		echo_retry " Empty value, please retry"
		read set
	done
	
	case $variable in
		iso_name)
			iso_name="${set}"
			echo_valid " Iso name is now : $set";;
		iso_version)
			iso_version="$set"
			echo_valid " Iso version is now : $set";;
		iso_label)
			iso_label="$set"
			echo_valid " Iso label is now : $set";;
		iso_publisher)
			iso_publisher="$set"
			echo_valid " Iso publisher is now : $set";;
		iso_application)
			iso_application="$set"
			echo_valid " Iso application is now : $set";;
		install_dir)
			install_dir="$set"
			echo_valid " Intallation directory is now : $set";;
		out_dir)
			out_dir="$set"
			echo_valid " Output directory is now : $set";;
		sfs_mode)
			while [[ $set != @(img|sfs) ]]; do
				echo_retry " sfs_mode must be img or sfs, please retry"
				read set
			done
			sfs_mode="$set"
			echo_valid " Sfs mode is now : $set";;
		sfs_comp)
			while [[ $set != @(gzip|lzma|lzo|xz) ]]; do
				echo_retry " sfs_comp must be gzip or lzma or lzo or xz, please retry"
				read set
			done
			sfs_comp="$set"
			echo_valid " Sfs compression is now : $set";;
		verbose)
			reply_answer
			if (( ! "$rc" )); then
				unset rc
				verbose="-v"
				d_verbose="yes"
				echo_valid " Verbose enabled"
			else
				unset rc
				unset verbose
				d_verbose="no"
				echo_notvalid " Verbose disabled"
			fi;;
	esac
}

enter_iso(){
	$dir/.build/iso_build/./build_iso ${verbose}
}

clean_work_dir(){
	if [[ -d $work_dir ]]; then
		echo_display " Removing $work_dir"
		rm -R "$work_dir"
	else
		echo_display " $work_dir doesn't exist"
	fi
}
