#!/usr/bin/bash
## This script is under license BEER-WARE.
# "THE BEER-WARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal
shopt -s extglob

export TMPDIR=

##		Shell color 

bold=$(tput bold)
reset=$(tput sgr0)
red=$(tput setaf 1)
bred=${bold}$(tput setaf 1)
green=$(tput setaf 2)
bgreen=${bold}$(tput setaf 2)
yellow=$(tput setaf 3)
byellow=${bold}$(tput setaf 3)
blue=$(tput setaf 4)
bblue=${bold}$(tput setaf 4)

## 		Some variables

newroot="/mnt"
editor="mcedit"
config_dir="openbox"
gen_dir=`pwd`/config
cache_dir="/var/cache/pacman/pkg"
yaourt_cache="$newroot/var/cache/pacman/pkg" 
tmp_yaourt="$newroot/tmp/"
gpg_dir="/opt/obarun-install/gnupg"
file_mounted=""
newuser=""
zone=""
subzone=""
hostname=""
locale="" 
locale_rc=""
pack=0
rc=""
git_addr="https://github.com/Obarun/obarun-install.git"

## 		Information display by the script 

echo_bold(){
	echo "${bold}${1}${reset}"
}
echo_info(){
	echo "${byellow}==>>${1}${reset}"
}
echo_info_menu(){
	echo "${byellow}${1}${reset}"
}
echo_retry(){
	echo "${bblue}==>>${1}${reset}"
}
echo_valid(){
	echo "${bgreen}==>>${1}${reset}"
}
echo_display(){
	echo "${bold}==>>${1}${reset}"
}
answer(){
	echo_retry " Please answer y or n :"
}



## 		Exit

die (){
      local message code 
      message="$1"
      [[ -n "$2" ]] && code="$2" || code=1
      if [[ -n "$message" ]] ; then
        echo "${bred}==>> Error: ${message}; exit status ${code}${reset}"
      else
        echo "${bred}==>> Error: exiting with status ${code}${reset}"
      fi
      exit 1
}

## 		Clean on exit

clean_install(){
	check_mounted
	if [[ "$file_mounted" != "" ]]; then
		echo_info " Umount filesystem in $newroot"
		umount -R $newroot/{proc,sys,dev,tmp,run}
	fi
	if [[ $(awk -F':' '{ print $1}' /etc/passwd | grep usertmp) >/dev/null ]]; then
		echo_info " Removing user usertmp"
		rem_usertmp &>/dev/null
	fi
	if [[ -e /etc/yaourtrc.ori.obarun ]]; then
		mv /etc/yaourtrc.ori.obarun /etc/yaourtrc
	fi
	if [[  -e "$newroot/etc/functions" ]]; then
		rm "$newroot/etc/functions" || die "File functions not exist"
	fi
	if [[  -e "$newroot/etc/customizeChroot" ]]; then
		rm "$newroot/etc/customizeChroot" || die " File customizeChroot not exist"
	fi
	
	
	exit
}

rem_usertmp(){
	echo_info " Removing user : usertmp"
	userdel -r usertmp
	sed -i '/usertmp/d' /etc/sudoers
}

##		Update package automaticaly

pac_update(){
	local status pkgname build_dir
	pkgname="obarun-install"
	dir=`pwd`
	
	# make build_dir directory
	make_build_dir(){
		if ! [ -d "$dir/.build" ]; then
			echo_info " Create necessary directory"
			mkdir -p -m0755 "$dir/.build"
			build_dir="$dir/.build"
		else
			build_dir="$dir/.build"
		fi
	}
	
	# check if pkgbuild exist
	copy_pkgbuild(){
		echo_info " Copy PKGBUILD to ${green}[$build_dir/$pkgname]${reset}"
		cp -f "$dir"/.PKGBUILD "$build_dir/$pkgname/PKGBUILD"
	}
	
	# make package
	make_package(){
		user_tmp
		copy_pkgbuild || die " Impossible to copy .PKGBUILD"
		chown -R usertmp:users "$build_dir"
		cd "$build_dir/$pkgname"
		echo_info " Launch makepkg and install the new version if exist"
		sudo -u usertmp makepkg -Cfi --nosign --noconfirm --needed
		sleep 2
	}
	
	# check current version 
	check_version(){
		cd "$build_dir/$pkgname"
		local curr_version git_version
		curr_version=$(pacman -Qi obarun-install | grep "Version" | awk -F": " '{print $2}' | sed 's:-1::')
		git_version=$(git rev-parse --short HEAD)
	
		if ! [[ "$curr_version" == "$git_version" ]]; then
			check_update || die " Impossible to udpdate $pkgname"
			make_package || die " Impossible to make the package"
		fi
	}	
		
	# check git repositories
	check_update(){
		cd "$build_dir/$pkgname"
		status=$(git pull origin 2>/dev/null)
		if [[ $status == "Already up-to-date." ]]; then
			echo_valid " Git $status Nothing to do"
			sleep 2
		else
			echo_info " $pkgname is out of date, updating please wait"
			make_package || die " Impossible to make the package"
		fi
	}
	
	make_build_dir
	
	if ! [ -d "$build_dir/$pkgname" ]; then
		cd "$build_dir"
		echo_info " Clone repository form ${green}[$git_addr]${reset}"
		git clone "$git_addr"
		make_package || die " Impossible to make the package"
	else
		check_version || die " Impossible to check the current version"
		check_update || die " Impossible to udpdate $pkgname"
	fi	
}

## 		Create needed directory

create_dir(){
	if ! [ -d "$newroot/proc" ]; then 
		echo_info " Create needed directory in ${newroot}"
		mkdir -m 0755 -p "$newroot"/var/{cache/pacman/pkg,lib/pacman,log} "$newroot"/{dev,run,etc}
		mkdir -m 0755 -p "$newroot"/dev/{pts,shm}
		mkdir -m 1777 -p "$newroot"/tmp
		mkdir -m 0555 -p "$newroot"/{sys,proc}
	else
		echo_valid " Directory needed already exists"
	fi
}

##		check if $newroot is a valid mountpoint

check_mountpoint(){
	if ! mountpoint -q "$newroot"; then
			echo_retry " This is not a valid mountpoint"
			echo_retry " You need to mount a device on $newroot or choose another directory"
			(sleep 4) && echo_info " Returning to the main_menu" && (sleep 1) && main_menu
	fi
}

##		Already mounted or not

check_mounted(){
	file_mounted=$(mount | grep "$newroot"/proc)
}

## 		Mounting necessary directory

mount_dir(){
	check_mounted
	if [[ "$file_mounted" = "" ]]; then
		echo_info " Mounting filesystem in ${newroot}"
		mount -o nosuid,noexec,nodev -t proc proc "$newroot"/proc
		mount -o nosuid,noexec,nodev -t sysfs sys "$newroot"/sys 
		mount -o mode=0755,nosuid -t devtmpfs dev "$newroot"/dev 
		mount -o mode=0620,gid=5,nosuid,noexec -t devpts devpts "$newroot"/dev/pts 
		mount -o mode=1777,nosuid,nodev -t tmpfs shm "$newroot"/dev/shm 
		mount -o nosuid,nodev,mode=0755 -t tmpfs run "$newroot"/run 
		mount -o mode=1777,strictatime,nodev,nosuid -t tmpfs tmp "$newroot"/tmp 
	else
		echo_valid " Filesystem already mounted in ${newroot}"
	fi
}

## 		Check list option

check_elements(){
	for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
}

## 		Select, check editor

select_editor(){
	editors_list=("nano" "vi" "mcedit");
	echo_display " Select your editor :"
	select editor in "${editors_list[@]}"; do
		if check_elements "$editor" "${editors_list[@]}"; then
			echo_valid " Your editor is now : $editor"
		break
		else 
			echo_retry " Invalid option, enter 1 or 2 :"
		fi
	done
}

check_editor(){
	if [[ "$editor" == "" ]]; then
		editor="mcedit"
	fi
}

## 		Select config directory

choose_dir(){
	dir_list=$(ls -U `pwd`/config/)
	echo_display " Select the directory you want to use :"
	select dir in $dir_list; do
		if check_elements "$dir" $dir_list; then
			config_dir="$dir"	 
		break
		else 
			echo_retry " Invalid number, retry :"
		fi
	done
	echo_valid " You chose $config_dir"
}

##		Choose cache directory for pacman

choose_cache(){
	echo_display " Enter the path for your own cache directory"
	read cache_dir
	while [[ ! -d "$cache_dir" ]]; do
		echo_retry " $cache_dir is not a directory, please retry:"
		read cache_dir
	done
	# the directory must be not empty, may be bug here
	while [[ $(ls $cache_dir | grep "pkg.tar.xz") = "" ]]; do
		echo_retry " Is not a valid directory for pacman, please retry:"
		read cache_dir
	done
	echo_valid " Your cache directory is now : $cache_dir"
}

## 		Edit pacman.conf

edit_pacman(){
	check_editor
	"$editor" "$gen_dir/$config_dir/pacman.conf"		
}

## 		Edit customizeChroot file

edit_customize_chroot(){
	check_editor
	"$editor" "$gen_dir/$config_dir/customizeChroot"
	if [[ -d "$newroot/etc" ]]; then
		cp -f "$gen_dir/$config_dir/customizeChroot" "$newroot/etc/customizeChroot" || die " File customizeChroot not exist"
	fi
}

## 		Create temporary users for yaourt

user_tmp(){
	if ! [[ $(awk -F':' '{ print $1}' /etc/passwd | grep usertmp) ]]; then
		echo_info " Create a temporary user needed for the scripts"
			if [[ -e /etc/sudoers ]]; then
				# declaring usetmp on adm group is certainly a bad idea
				useradd -m -g users -G "wheel,disk,storage,optical,floppy,adm,network" -s /bin/bash usertmp || die " Impossible to create user : usertmp"
				echo "%usertmp ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
			else
				echo "${bred}==>> The file /etc/sudoers doesn't exists,"
				echo_info " Installing sudo package"
				pacman -S sudo
				user_tmp
			fi
	fi
}

		
## 		Select root directory

rootdir(){	
	echo_display " Enter your root directory :"
	read newroot
	
	until [[ -d "$newroot" ]]; do
		echo_retry " This is not a directory, please retry :"
		read newroot
	done
	
	while ! mountpoint -q "$newroot"; do
		echo_retry " This is not a valide mountpoint, please retry :"
		read newroot
	done
	
	echo_valid " Your root directory for installation is now : $newroot"
}

## Check if needed packages is installed

check_pac_needed(){
	if [[ ! $(pacman -Qs arch-install-scripts) >/dev/null ]]; then
		echo_info " Installing arch-install-scripts"
		pacman -S arch-install-scripts --config "$gen_dir/$config_dir/pacman.conf" || die " Impossible to install the package arch-install-scripts"
	else
		echo_valid " arch-install-scripts : already installed"
	fi
	if [[ ! $(pacman -Qs yaourt) >/dev/null ]]; then
		echo_info " Installing yaourt"
		pacman -S base-devel package-query yaourt --config "$gen_dir/$config_dir/pacman.conf" || die " Impossible to install the package arch-install-scripts"
	else
		echo_valid " yaourt : already installed"
	fi
}

##		Select packages list

select_list(){
	check_editor
	pac_list=$(ls "$gen_dir"/"$config_dir"/package_list/)
	pac_list+=" Exit"
	echo_info " File named repo_* concerns the packages provides by repositories defined in pacman.conf"
	echo_info " File named aur_* concerns the packages from AUR"
	echo_display " Select the list you want to edit then select Exit number to return at main menu :"
	select list in $pac_list; do
		case "$list" in
			Exit)break;;
			*)if check_elements "$list" $pac_list; then
				"$editor" "$gen_dir/$config_dir/package_list/$list"
			  else 
				echo_retry " Invalid number, retry :"
			  fi
		esac
	done
}

## 		Install packages with pacman

pac_install(){
		echo_info " Install base first"
		pacman -r "$newroot" -S $(grep -h -v ^# $gen_dir/$config_dir/package_list/base) --config "$gen_dir/$config_dir/pacman.conf" --cachedir "$cache_dir" --noconfirm #2>/dev/null || die " Failed to install packages"
		pacman -r "$newroot" -S $(grep -h -v ^# $gen_dir/$config_dir/package_list/repo_*) --config "$gen_dir/$config_dir/pacman.conf" --cachedir "$cache_dir" --noconfirm #2>/dev/null || die " Failed to install packages"
}

## 		Install package from aur

aur_install(){
	chmod -R 0777 "$yaourt_cache" ## this turn around is little ugly but necessary to allow written by user "usertmp"
	if [[ ! -d "$newroot/var/lib/pacman/sync" ]]; then 
		sync="y"
	else
		sync=""
	fi
		
	if [[ ! -e /etc/yaourtrc.ori.obarun ]]; then
		if [[ -e /etc/yaourtrc ]]; then
			cp /etc/yaourtrc /etc/yaourtrc.ori.obarun
		fi
		sed -i "s:#TMPDIR=.*$:TMPDIR=$tmp_yaourt:" /etc/yaourtrc
		sed -i "s:#EXPORT=.*$:EXPORT=1:" /etc/yaourtrc
		sed -i "s:#EXPORTDIR=.*$:EXPORTDIR=$yaourt_cache:" /etc/yaourtrc
	fi	
	aur_cache
	chmod -R 0755 "$yaourt_cache"
}

aur_cache(){
	local list item hit wanted name p_hit passed
	local -a installed notinstalled y_cached p_cached result
	
	mapfile -t installed < <(pacman -r "$newroot" -Qsq)
	mapfile -t notinstalled < <(cat $gen_dir/$config_dir/package_list/aur_* | grep -v "#" | sed  '/^ *$/d')
	mapfile -t y_cached < <(ls -1 -p $yaourt_cache/ | grep -v '/$' | grep -v "gz" | sed 's/-[0-9].*$//g')
	mapfile -t p_cached < <(ls $cache_dir | sed 's/-[0-9].*$//g' | uniq)
	
	echo_info " Ckeck installed packages for yaourt"
	# diff between wanted and installed	
	list=" ${installed[@]} "                  
	for item in "${notinstalled[@]}"; do
		if ! [[ $list =~ " $item " ]] ; then  
			result+=($item,)
		fi
	done
	
	# TODO : FAIL try to install a package group instead of package name
	# install from cache if present else download it
	if [[ -n "${result[@]}" ]]; then
		while read -d "," wanted; do
			if [[ -n "${y_cached[@]}" ]]; then
				for name in "${y_cached[@]}"; do
					if [ $name = $wanted ]; then
						hit=0
					fi
				done
				for name in "${p_cached[@]}";do
					if [ $name = $wanted ]; then
						p_hit=0
					fi
				done
				if [[ $p_hit = 0 ]]; then
						# check for last version
						# TODO : can cause problem if the cache directory is out of date, need to be improved
						pack=$(ls -1t $cache_dir | grep $wanted | head -1) 
						pacman -r "$newroot" -U"$sync" "$cache_dir"/$pack --noconfirm || die " Failed to install packages" 
						p_hit=""
						hit=""
						passed=0
				fi
				if [[ $hit = 0 ]]; then
					pacman -r "$newroot" -U"$sync" "$yaourt_cache"/$wanted*.xz --noconfirm || die " Failed to install packages" 
					hit=""
				else
					if [[ $passed != 0 ]]; then
						sudo -u usertmp yaourt -r "$newroot" -S"$sync" "$wanted" --noconfirm || die " Failed to install packages" 
						hit=""
						passed=""
					fi
				fi
			else
				sudo -u usertmp yaourt -r "$newroot" -S"$sync" "$wanted" --noconfirm || die " Failed to install packages"
			fi
		done <<< ${result[@]}
	else
		echo_valid " Nothing to do for yaourt"
	fi
}

##		Copying file needed

copy_file(){
	echo_info " Check needed files in ${newroot}"
	if [[  ! -e "$newroot/etc/resolv.conf" ]]; then 
		cp /etc/resolv.conf "$newroot/etc/resolv.conf" || die " Impossible to copy the file resolv.conf"
	else
		echo_valid " File resolv.conf already exist"
	fi
	if [[ ! -e "$newroot/etc/functions" ]]; then
		cp "`pwd`/functions" "$newroot/etc/functions" || die "File functions not exist"
	else
		echo_valid " File functions already exist"
	fi
	if [[ ! -e "$newroot/etc/customizeChroot" ]]; then
		cp "$gen_dir/$config_dir/customizeChroot" "$newroot/etc/customizeChroot" || die " File customizeChroot not exist"
	else
		echo_valid " File customizeChroot already exist"
	fi
}
	
##		Sync database

sync_data(){
	echo_info " Check if gpg key exist on [$gpg_dir]"
	if ! pacman-key -u --gpgdir "$gpg_dir" &>/dev/null; then
		echo_info " Gpg doesn't exist on [$gpg_dir], create it..."
		pac_key "$gpg_dir"
	else
		echo_valid " Gpg key exist, Refresh it..."
		pacman-key -u --gpgdir "$gpg_dir"
		# paranoia here : make sure Eric Vidal key exist
		if ! pacman-key --list-keys 7B45DAAC --gpgdir "$gpg_dir" &>/dev/null; then
			echo_info " Add Eric Vidal gpg signature, please wait"
			pacman-key -r 7B45DAAC $gpg_opts
			pacman-key --lsign-key 7B45DAAC $gpg_opts
		fi 
	fi
	echo_info " Synchronize database"
	pacman -Sy --config "$gen_dir/$config_dir/pacman.conf" || die " Impossible to synchronize database"
	
	echo_info " Copying database on $newroot/var/lib/pacman/sync/"	
	mkdir -p -m0755 "$newroot/var/lib/pacman/sync/"
	cp /var/lib/pacman/sync/*.db "$newroot/var/lib/pacman/sync/" || die "/var/lib/pacman/sync/*.db doesn't exit on host"
		
}

##		Install packages if pack = 0 otherwise call resume_install function

install_pack(){
	if [[ "$pack" == 0 ]]; then
		echo_info " Check if gpg signature exist on [$gpg_dir]"
		if ! pacman-key -u --gpgdir "$gpg_dir" &>/dev/null; then
			echo_info " Gpg doesn't exist on [$gpg_dir], create it..."
			pac_key "$gpg_dir"
		else
			echo_info " Refresh gpg before install on [$gpg_dir]"
			pacman-key -u --gpgdir "$gpg_dir"
		fi
				
		echo_info " Install packages from lists"
		pac_install || die " Impossible to install packages from repository" 
		aur_install || die " Impossible to install packages from AUR"
	else
		resume_install
		aur_install
	fi
			
}


##		Only install packages are not present yet

resume_install(){
	local list item
	local -a installed notinstalled result
	
	# TODO : bug -> nÂ°7 need to be launch one time else /var/lib/pacman doesn't exist
	mapfile -t installed < <(pacman -r "$newroot" -Qsq)
	mapfile -t notinstalled < <(grep -h -v ^# $gen_dir/$config_dir/package_list/repo_*)
	echo_info " Ckeck installed packages for pacman"
	list=" ${installed[@]} "                #include blank    
		for item in ${notinstalled[@]}; do
			if ! [[ $list =~ " $item " ]] ; then  
				result+=($item)
			fi
		done
	
	#install package
	if [[ -n "${result[@]}" ]]; then
		echo_info " Install missing packages"
		pacman -r "$newroot" -S "${result[@]}" --config "$gen_dir/$config_dir/pacman.conf" --cachedir "$cache_dir" --noconfirm 2>/dev/null || die " Failed to install packages"
	else
		echo_valid " Nothing to do for pacman"
	fi
}

##		Generate key

pac_key(){
	local gpg_opts
	
	if ! [ -z "$1" ]; then
		gpg_opts="--gpgdir $1"
	fi
	
	echo_info " Start pacman-key"
	haveged -w 1024
	
	# pacman-key -r failed without /root/.gnupg
	# create it by dirmngr
	# TODO: find a turn around
	if ! [ -d /root/.gnupg/ ]; then
		dirmngr &>/dev/null & pkill dirmngr
	fi
	
	pacman-key --init $gpg_opts
	pacman-key --populate archlinux $gpg_opts
	
	if ! pacman-key --list-keys 7B45DAAC $gpg_opts &>/dev/null; then
		echo_info " Add Eric Vidal gpg signature, please wait"
		pacman-key -r 7B45DAAC $gpg_opts
		pacman-key --lsign-key 7B45DAAC $gpg_opts
	fi
	pkill haveged
	pkill gpg-agent
	pkill dirmngr
	
	if [ -z "$1" ]; then
		echo_info " Change pacman.conf configuration"
		sed -i "s:SigLevel = Never.*#:SigLevel = Required DatabaseOptional:" /etc/pacman.conf
		sed -i "s:#SigLevel = PackageRequired:SigLevel = PackageRequired:" /etc/pacman.conf
	fi
	# unset gpg_opts
	gpg_opts=
}

##		Generate fstab

gen_fstab(){
	echo_info " Generate fstab"
	genfstab -p "$newroot" > "$newroot/etc/fstab" || die " Impossible to generate fstab"
}

##		Copy directory rootfs in $newroot

copy_rootfs(){
	echo_info " Copying configuration files in ${newroot}"
	cp -af `pwd`/config/"$config_dir"/rootfs/* "$newroot"/ || die " Impossible to copy files"
}

##		Customize newroot

enter_chroot(){
	echo_info " Check for needed"
	check_mountpoint
	create_dir
	mount_dir
	user_tmp
	copy_file
	sync_data
	copy_rootfs
	define_root
	echo_info " Enter in chroot of ${newroot}"	
	if [[ ! -e "$newroot/etc/functions" ]]; then
		cp "`pwd`/functions" "$newroot/etc/functions" || die "File functions not exist"
	else
		echo_valid " File functions already exist"
	fi
	if [[ ! -e "$newroot/etc/customizeChroot" ]]; then
		cp "$gen_dir/$config_dir/customizeChroot" "$newroot/etc/customizeChroot" || die " File customizeChroot not exist"
	else
		echo_valid " File customizeChroot already exist"
	fi
	chroot "$newroot" /etc/customizeChroot || die " Failed to enter in ${newroot} or Failed to execute correctly the file"
}

##		Enter in $newroot with mc

mc_newroot(){
	SHELL=/bin/sh chroot "$newroot" /usr/bin/mc
}

##		Open an interactive shell on newroot

call_shell(){
	echo_info " Tape exit when you have finished"
	if [[ -e "$newroot/usr/bin/zsh" ]]; then
		SHELL=/bin/sh chroot "$newroot" /usr/bin/zsh 
	else
		SHELL=/bin/sh chroot "$newroot"
	fi
}

##		Define root user

define_root(){
	if [[ ! $(cat $newroot/etc/shadow | grep "root::") == "" ]]; then
		echo_info " Change shell for root user on $newroot"
		usermod -R "$newroot" -s /usr/bin/zsh root
		
		echo_info " Copy skeleton to $newroot/root/"
		cp -rT "$newroot/etc/skel/" "$newroot/root/"
		
		chmod 0700 "$newroot/root"
		
		echo_info " You need to define root password"
		pass_root
		echo_valid " root user was modified successfully"
	fi
	if [[ -e "$newroot/root/.zlogin" ]]; then
		echo_info " Removing auto-login for root"
		rm "$newroot/root/.zlogin"
	fi
}

pass_root(){
	passwd -R "$newroot" root
	while [[ $? -ne 0 ]]; do
		echo_retry " Password do not match, please retry"
		passwd -R "$newroot" root
	done
}


##		Start the installation

install_system(){
	check_mountpoint
	create_dir
	mount_dir
	user_tmp
	copy_file
	sync_data
	check_pac_needed
	install_pack
	gen_fstab
	copy_rootfs
	define_root
	pack=0
}

## 		Main menu

main_menu(){

local step=100

while [[ "$step" !=  10 ]]; do
	clear
	echo_bold ""
	echo_bold ""
	echo_info_menu "***************************************************************************************"
	echo_info_menu "                            Main menu"
	echo_info_menu "***************************************************************************************"
	echo_bold ""
	echo_bold " Assumptions :"
	echo_bold "	- User has partitioned, formatted, and mounted partitions on a directory"
	echo_bold "	- Network is functional"
	echo_bold "	- A valid mirror appears in /etc/pacman.d/mirrorlist"
	echo_bold "	- Defaults for the options are specified in brackets"
	echo_bold ""
	echo_info_menu "***************************************************************************************"
	echo_info_menu "                            Configuration"
	echo_info_menu "***************************************************************************************"
	echo_bold ""
	echo_bold " 1  -  Select Editor ${green}[$editor]"
	echo_bold " 2  -  Choose your Desktop environment ${green}[$config_dir]"
	echo_bold " 3  -  Edit pacman.conf file used by the script"
	echo_bold " 4  -  Define cache directory for pacman ${green}[$cache_dir]"
	echo_bold " 5  -  Edit the list of packages that will be installed (AUR including)"
	echo_bold " 6  -  Enter root directory for installation ${green}[$newroot]"
	echo_bold ""
	echo_info_menu "***************************************************************************************"
	echo_info_menu "                            Installation"
	echo_info_menu "***************************************************************************************"
	echo_bold ""
	echo_bold " 7  -  Install the base system"
	echo_bold " 8  -  Launch the script customizeChroot"
	echo_bold ""
	echo_bold " 9  -  Resume an aborted installation"	 	
	echo_bold ""
	echo_info_menu "***************************************************************************************"
	echo_info_menu "                            Edition"
	echo_info_menu "***************************************************************************************"
	echo_bold ""
	echo_bold " 10 -  Edit the script customizeChroot"
	echo_bold " 11 -  Launch a shell on ${green}[$newroot]${reset}${bold} directory"
	echo_bold " 12 -  Browse ${green}[$newroot]${reset}${bold} with Midnight Commander"
	echo_bold ""
	echo_bold " ${red}13 -  Exit installation script"
	echo_bold ""
	echo_info " Enter your choice :";read  step

		case "$step" in 
			1)	select_editor;;
			2)	choose_dir;; # Never comment this options
			3)	edit_pacman;;
			4)	choose_cache;;
			5)	select_list;;
			6)	rootdir;; # Never comment this options
			7)	install_system;;
			8)	enter_chroot;;
			9)	pack=1
				install_system;;
			10)	edit_customize_chroot;;
			11) call_shell;;
			12)	mc_newroot;;
			13) echo_info " Exiting"
				exit;;
			*) echo_retry " Invalid number, Please retry: "
		esac
		echo_info " Press enter to return to the Main menu"
		read enter 
done
}

#####################################		Functions for customizeChroot script

## 		CustomizeChroot menu

customizeChroot_menu(){

locale step=100

while [[ "$step" !=  8 ]]; do
	clear
	echo_bold ""
	echo_bold ""
	echo_info_menu "**************************************************************"
	echo_info_menu "              CustomizeChroot menu"
	echo_info_menu "**************************************************************"
	echo_bold ""
	echo_bold " 1  -  Define hostname ${green}[$hostname]"
	echo_bold " 2  -  Define locale ${green}[$locale]"
	echo_bold " 3  -  Define localtime ${green}[$zone/$subzone]"
	echo_bold " 4  -  Create a new user ${green}[$newuser]"
	echo_bold " 5  -  Edit rc.conf file"
	echo_bold " 6  -  Browse with Midnight Commander"
	echo_bold ""
	echo_bold " 7  -  Continue the installation"
	echo_bold ""
	echo_bold " ${red}8  -  Return to the main menu"
	echo_bold ""
	echo_bold ""
	echo_info " Enter your choice :";read  step

		case "$step" in 
			1)	define_hostname;;
			2)	define_locale;; 
			3)	call_localtime;;
			4)	define_user;;
			5)	edit_rc_conf;;
			6)	mc_enter;;
			7)	echo_info " Continue installation"
				break;;
			8)	exit;;
			*) echo_retry " Invalid number, please retry:"
		esac
		echo_info " Press enter to return to the customizeChroot menu"
		read enter 
done
}

##		Define resolv.conf

define_resolv(){
	echo_info " Define resolv.conf"
	if [[ -e /etc/resolv.conf.pacorig ]]; then 
		mv /etc/resolv.conf.pacorig /etc/resolv.conf
	fi
}


##		Enter in the fresh installation with mc

mc_enter(){
	mc /
}

## 		Define hostname

define_hostname(){
	if [[ "$hostname" != "" ]]; then
		sed -i 's/ .*$//' /etc/hosts
	fi
	echo_display " Enter your hostname"
	read hostname
	sed -i "s/HOSTNAME=\".*$/HOSTNAME=\"$hostname\"/g" /etc/rc.conf
	echo "$hostname" > /etc/hostname
	sed -i '/127.0.0.1/s/$/ '$hostname'/' /etc/hosts
	sed -i '/::1/s/$/ '$hostname'/' /etc/hosts
	echo_valid " hostname is now : $hostname"
}

##		Edit rc.conf

edit_rc_conf(){
	"$editor" /etc/rc.conf
}

##		Define locale

define_locale(){
	echo_info " Define your locale by uncomment desired line, only one line is allowed ($editor will be launch in 2 sec)"
	sleep 02
	"$editor" /etc/locale.gen
	locale-gen
	locale=$(grep -v "#" /etc/locale.gen | awk -F " " '{ print $1 }')
	echo LANG="$locale" > /etc/locale.conf
    echo LC_COLLATE=C >> /etc/locale.conf
	locale_rc=$(grep -v "#" /etc/locale.gen | sed 's/ UTF-8//g' | awk -F "_" '{ print $1 }')
	sed -i "s,KEYMAP=\".*$,KEYMAP=\"$locale_rc\",g" /etc/rc.conf
	echo_valid " Locale was created successfully"
	# define local for root
	if [[ -e "/root/.xinitrc" ]]; then
		locale_xinit=""
		locale_xinit=$(grep -v "#" /etc/locale.gen | sed 's/ UTF-8//g' | awk -F "_" '{ print $1 }')
		echo_info " Define locale in /root/.xinitrc"
		sed -i 's/#setxkbmap.*$/setxkbmap\ '$locale_xinit'\ \&/g' /root/.xinitrc
		sed -i 's/setxkbmap.*$/setxkbmap\ '$locale_xinit'\ \&/g' /root/.xinitrc
	fi
}

##		Define localtime

define_localtime(){
	zone_list=$(ls -d --group-directories-first /usr/share/zoneinfo/* | awk -F "/usr/share/zoneinfo/" '{ print $2 }' | uniq)
	zone_list+=" Exit"
	select zone in $zone_list; do
		case $zone in 
			Exit)customizeChroot_menu
			break;;
			*)if check_elements "$zone" $zone_list; then
				if [[  -d "/usr/share/zoneinfo/$zone" ]]; then
					sub_zone_list=$(ls /usr/share/zoneinfo/$zone/* | awk -F "/usr/share/zoneinfo/$zone/" '{ print $2 }') 
					sub_zone_list+=" Exit"
					select subzone in $sub_zone_list; do
						case $subzone in
							Exit)define_localtime
								break;;
							*)if check_elements "$subzone" $sub_zone_list; then
								break
							else
								echo_retry " Invalid number, retry :"
							fi
						esac
					done
				fi
			break	
			else 
				echo_retry " Invalid number, retry :"
			fi
		esac
	done
}

call_localtime(){
	echo_display " Choose your country/department"
	define_localtime
	if [[ "$subzone" != "" ]]; then
		ln -sf /usr/share/zoneinfo/$zone/$subzone /etc/localtime
		sed -i "s/TIMEZONE=\".*$/TIMEZONE=\"$zone\/$subzone\"/g" /etc/rc.conf
	else
		ln -sf /usr/share/zoneinfo/$zone /etc/localtime
		sed -i "s/TIMEZONE=\".*$/TIMEZONE=\"$zone\"/g" /etc/rc.conf
	fi
	echo_valid " your localtime is now : $zone/$subzone"
}

##		Define a new user

define_user(){
	echo_display " Enter the name for the user"
	read newuser
	while [[ ! $(cat /etc/passwd | grep "$newuser") == "" ]]; do
		echo_retry " $newuser already exit, please enter another name :"
		read newuser
	done
	while [[ ${#newuser} -eq 0 ]] || [[ $newuser =~ \ |\' ]] || [[ $newuser =~ [^a-z0-9\ ] ]]; do
		echo_retry " Invalid user name. Please retry :"
		read newuser
	done
	echo_valid " Create user $newuser"
	useradd -m -g users -G "audio,floppy,log,network,rfkill,scanner,storage,optical,power,wheel,video" -s /usr/bin/zsh "$newuser"
	if [[ -e "/home/$newuser/.xinitrc" ]]; then
		locale_xinit=""
		locale_xinit=$(grep -v "#" /etc/locale.gen | sed 's/ UTF-8//g' | awk -F "_" '{ print $1 }')
		sed -i 's/#setxkbmap.*$/setxkbmap\ '$locale_xinit'\ \&/g' /home/$newuser/.xinitrc
		sed -i 's/setxkbmap.*$/setxkbmap\ '$locale_xinit'\ \&/g' /home/$newuser/.xinitrc
	fi
	echo_info " You need to define $newuser password"
	pass_user
	echo_valid " User $newuser was created successfully" 
}

pass_user(){
	passwd "$newuser"
	while [[ $? -ne 0 ]]; do
		echo_retry " Password do not match, please retry"
		passwd "$newuser"
	done
}

##		Reply functions
## return rc=0 for yes
## return rc=1 for no
reply_answer(){
	local reply
	read reply
	while [[ ! "$reply" = @(y|n) ]]; do
		answer
		read reply
	done
	if [ "$reply" == "y" ]; then
		rc=0
	else
		rc=1
	fi	
}
	
##		Define/configure Bootloader

# TODO : let the choice at user to choose between bootloader
#define_bootloader(){
	
#}

syslinux_install(){
	local opts="$1"
	echo_info " Installing bootloader: syslinux"
	syslinux-install_update $opts
	
	echo_info " Maybe the partition name in the root parameter needs to be replaced."
	echo_info " Be sure to point the root partition in the line APPEND."
	syslinux_edit
	echo_info " Syslinux install terminate"
}

syslinux_edit(){
	echo_display " Do you want edit syslinux.cfg [y|n]"
	reply_answer
	if [[ "$rc" == 0 ]]; then
		rc=""
		check_editor
		"$editor" "/boot/syslinux/syslinux.cfg"
	fi
}

syslinux_menu(){

	local step=100 options=""

	while [[ "$step" != 5 ]]; do
		clear
	
		echo_bold ""
		echo_bold ""
		echo_info_menu "**************************************************************"
		echo_info_menu "              Syslinux configuration menu"
		echo_info_menu "**************************************************************"
		echo_bold ""
		echo_bold " 1 - Install files, set boot flag, install MBR ${green}[-iam]"
		echo_bold " 2 - Install files, set boot flag ${green}[-ia]"
		echo_bold " 3 - Install only MBR ${green}[-m]"
		echo_bold " 4 - Only set boot flag ${green}[-a]"
		echo_bold ""
		echo_bold " ${red}5 - Exit"
		echo_bold ""
		echo_bold ""
		echo_info " Enter your choice :";read step

			case "$step" in
				1)	options="-iam"
					break;;
				2) 	options="ia"
					break;;
				3) 	options="-m"
					break;;
				4) 	options="-a"
					break;;
				5) 	echo_info " Exiting"
					exit;;
				*) 	echo_retry " Invalid number, please retry:"
					echo_info " Press enter to return to syslinux configuration menu"
					read enter;;
			esac	
	done
	
	syslinux_install "$options"
}
